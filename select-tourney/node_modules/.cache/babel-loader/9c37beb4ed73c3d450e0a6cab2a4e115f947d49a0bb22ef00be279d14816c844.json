{"ast":null,"code":"import { MODE_PANNING, MODE_ZOOMING, TOOL_AUTO, TOOL_NONE, TOOL_PAN, TOOL_ZOOM_IN, TOOL_ZOOM_OUT } from '../constants';\nimport { getSVGPoint, setFocus } from './common';\nimport { autoPanIfNeeded, startPanning, stopPanning, updatePanning } from './pan';\nimport { startZooming, stopZooming, updateZooming, zoom } from './zoom';\nimport mapRange from '../utils/mapRange';\nexport function getMousePosition(event, ViewerDOM) {\n  let {\n    left,\n    top\n  } = ViewerDOM.getBoundingClientRect();\n  let x = event.clientX - Math.round(left);\n  let y = event.clientY - Math.round(top);\n  return {\n    x,\n    y\n  };\n}\nexport function onMouseDown(event, ViewerDOM, tool, value, props) {\n  let coords = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  const {\n    x,\n    y\n  } = coords || getMousePosition(event, ViewerDOM);\n  let nextValue = value;\n  switch (tool) {\n    case TOOL_ZOOM_OUT:\n      let SVGPoint = getSVGPoint(value, x, y);\n      nextValue = zoom(value, SVGPoint.x, SVGPoint.y, 1 / props.scaleFactor, props);\n      break;\n    case TOOL_ZOOM_IN:\n      nextValue = startZooming(value, x, y);\n      break;\n    case TOOL_AUTO:\n    case TOOL_PAN:\n      nextValue = startPanning(value, x, y);\n      break;\n    default:\n      return value;\n  }\n  event.preventDefault();\n  return nextValue;\n}\nexport function onMouseMove(event, ViewerDOM, tool, value, props) {\n  let coords = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  const {\n    x,\n    y\n  } = coords || getMousePosition(event, ViewerDOM);\n  let forceExit = event.buttons === 0; //the mouse exited and reentered into svg\n  let nextValue = value;\n  switch (tool) {\n    case TOOL_ZOOM_IN:\n      if (value.mode === MODE_ZOOMING) nextValue = forceExit ? stopZooming(value, x, y, props.scaleFactor, props) : updateZooming(value, x, y);\n      break;\n    case TOOL_AUTO:\n    case TOOL_PAN:\n      if (value.mode === MODE_PANNING) nextValue = forceExit ? stopPanning(value) : updatePanning(value, x, y, props.preventPanOutside ? 20 : undefined);\n      break;\n    default:\n      return value;\n  }\n  event.preventDefault();\n  return nextValue;\n}\nexport function onMouseUp(event, ViewerDOM, tool, value, props) {\n  let coords = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  const {\n    x,\n    y\n  } = coords || getMousePosition(event, ViewerDOM);\n  let nextValue = value;\n  switch (tool) {\n    case TOOL_ZOOM_OUT:\n      if (value.mode === MODE_ZOOMING) nextValue = stopZooming(value, x, y, 1 / props.scaleFactor, props);\n      break;\n    case TOOL_ZOOM_IN:\n      if (value.mode === MODE_ZOOMING) nextValue = stopZooming(value, x, y, props.scaleFactor, props);\n      break;\n    case TOOL_AUTO:\n    case TOOL_PAN:\n      if (value.mode === MODE_PANNING) nextValue = stopPanning(value);\n      break;\n    default:\n      return value;\n  }\n  event.preventDefault();\n  return nextValue;\n}\nexport function onDoubleClick(event, ViewerDOM, tool, value, props) {\n  let coords = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  const {\n    x,\n    y\n  } = coords || getMousePosition(event, ViewerDOM);\n  let nextValue = value;\n  if (tool === TOOL_AUTO && !props.disableDoubleClickZoomWithToolAuto) {\n    const {\n      modifierKeys = []\n    } = props;\n    let SVGPoint = getSVGPoint(value, x, y);\n    let modifierKeysReducer = (current, modifierKey) => current || event.getModifierState(modifierKey);\n    let modifierKeyActive = modifierKeys.reduce(modifierKeysReducer, false);\n    let scaleFactor = modifierKeyActive ? 1 / props.scaleFactor : props.scaleFactor;\n    nextValue = zoom(value, SVGPoint.x, SVGPoint.y, scaleFactor, props);\n  }\n  event.preventDefault();\n  return nextValue;\n}\nexport function onWheel(event, ViewerDOM, tool, value, props) {\n  let coords = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  const {\n    x,\n    y\n  } = coords || getMousePosition(event, ViewerDOM);\n  if (!props.detectWheel) return value;\n  let delta = Math.max(-1, Math.min(1, event.deltaY));\n  let scaleFactor = mapRange(delta, -1, 1, props.scaleFactorOnWheel, 1 / props.scaleFactorOnWheel);\n  let SVGPoint = getSVGPoint(value, x, y);\n  let nextValue = zoom(value, SVGPoint.x, SVGPoint.y, scaleFactor, props);\n  event.preventDefault();\n  return nextValue;\n}\nexport function onMouseEnterOrLeave(event, ViewerDOM, tool, value, props) {\n  let coords = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  let nextValue = setFocus(value, event.type === 'mouseenter');\n  event.preventDefault();\n  return nextValue;\n}\nexport function onInterval(event, ViewerDOM, tool, value, props) {\n  let coords = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  let {\n    x,\n    y\n  } = coords;\n  if (!([TOOL_NONE, TOOL_AUTO].indexOf(tool) >= 0)) return value;\n  if (!props.detectAutoPan) return value;\n  if (!value.focus) return value;\n  return autoPanIfNeeded(value, x, y);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}