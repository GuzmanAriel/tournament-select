{"ast":null,"code":"import { scale } from './scale';\nimport { compose } from './transform';\n/**\n * Decompose a matrix into translation, scaling and rotation components, optionally\n * take horizontal and vertical flip in to consideration.\n * Note this function decomposes a matrix in rotation -> scaling -> translation order. I.e. for\n * certain translation T {tx, ty}, rotation R and scaling S { sx, sy }, it's only true for:\n *  decomposeTSR(compose(T, S, R)) === { translate: T, rotation: R, scale: S }\n * composing in a different order may yield a different decomposition result.\n * @param matrix {Matrix} Affine Matrix\n * @param  flipX {boolean} Whether the matrix contains vertical flip, i.e. mirrors on x-axis\n * @param  flipY {boolean} Whether the matrix contains horizontal flip, i.e. mirrors on y-axis\n * @returns {Transform} A transform object consisted by its translation, scaling\n * and rotation components.\n */\nexport function decomposeTSR(matrix, flipX = false, flipY = false) {\n  // Remove flip from the matrix first - flip could be incorrectly interpreted as\n  // rotations (e.g. flipX + flipY = rotate by 180 degrees).\n  // Note flipX is a vertical flip, and flipY is a horizontal flip.\n  if (flipX) {\n    if (flipY) {\n      matrix = compose(matrix, scale(-1, -1));\n    } else {\n      matrix = compose(matrix, scale(1, -1));\n    }\n  } else if (flipY) {\n    matrix = compose(matrix, scale(-1, 1));\n  }\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  let scaleX, scaleY, rotation;\n  if (a !== 0 || c !== 0) {\n    const hypotAc = Math.hypot(a, c);\n    scaleX = hypotAc;\n    scaleY = (a * d - b * c) / hypotAc;\n    const acos = Math.acos(a / hypotAc);\n    rotation = c > 0 ? -acos : acos;\n  } else if (b !== 0 || d !== 0) {\n    const hypotBd = Math.hypot(b, d);\n    scaleX = (a * d - b * c) / hypotBd;\n    scaleY = hypotBd;\n    const acos = Math.acos(b / hypotBd);\n    rotation = Math.PI / 2 + (d > 0 ? -acos : acos);\n  } else {\n    scaleX = 0;\n    scaleY = 0;\n    rotation = 0;\n  }\n\n  // put the flip factors back\n  if (flipY) {\n    scaleX = -scaleX;\n  }\n  if (flipX) {\n    scaleY = -scaleY;\n  }\n  return {\n    translate: {\n      tx: matrix.e,\n      ty: matrix.f\n    },\n    scale: {\n      sx: scaleX,\n      sy: scaleY\n    },\n    rotation: {\n      angle: rotation\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}